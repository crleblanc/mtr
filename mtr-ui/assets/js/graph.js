"use strict";

function utcToLocal(x) {
	return Date.parse(x) - new Date().getTimezoneOffset()*60*1000;
}

function plotData(div, csvUrl, csvData, graphOptions, thresholds, cache) {
    //Grey box for thresholds if specified:
    if (thresholds) {
        graphOptions.underlayCallback = function(canvas, area, g) {
          // convert coords to Dom x/y.  Only concerned with Y values
          var bottom = g.toDomCoords(0, thresholds[0]);
          var top = g.toDomCoords(0, thresholds[1]);

          canvas.fillStyle = "rgba(0, 255, 0, 0.05)";
          //start at (0,0) which is upper left, and make a box from bottom left to top right
          canvas.fillRect(0, top[1], area.w + area.x, bottom[1]-top[1]);
        }
    }

//    // Make the default time plotting in local time
//    if (!graphOptions.xValueParser) {
//        graphOptions.xValueParser = utcToLocal;
//    }

    if (!graphOptions.labels) {
        graphOptions.labels = csvData.headers;
    }

    var g = new Dygraph(
        div,
        csvData.data,
        graphOptions);

    // Set a zoom callback after the graph is created so we can pass it the Dygraph instance to be updated.
    if (!graphOptions.zoomCallback) {
        graphOptions.zoomCallback = function(minDate, maxDate, yRanges) {
            progressiveZoom(g, minDate, maxDate, yRanges, csvUrl, csvData, cache);
        };
    }

    g.updateOptions(graphOptions);
}

// Parse the CSV data to allow us to update it when zooming in.  This function is very specific to the CSV
// generated by mtr-api (headers on first line, date in first column, floats in all other columns).  Returns an 'object'
// of {headers:['header1', 'header2', ...], minMax:[minval, maxval], data:[[new Date(), 1.0, 2.0, ...],[new Date(), 2.0, 3.0, ...], ...]}
function parseCsv(text) {
    var allTextLines = text.split(/\r\n|\n/);
    var headers = allTextLines[0].split(',');
    var lines = [];
    var minMax = [null, null]; // TODO: if min and max are the same add a padding value to both

    for (var i=1; i < allTextLines.length; i++) {
        var line = allTextLines[i].split(',');
        if (line.length == headers.length) {

            var tarr = [];
            for (var j=0; j<headers.length; j++) {
                var value = line[j];
                if (!value) {
                    tarr.push(null);
                    continue;
                }

                var floatValue;
                if (j==0) {
                    tarr.push(new Date(value));
                } else {
                    floatValue = parseFloat(value);
                    tarr.push(floatValue);

                    // update the min and max values
                    if (minMax[0] == null) minMax[0] = floatValue;
                    if (minMax[1] == null) minMax[1] = floatValue;

                    minMax[0] = Math.min(minMax[0], floatValue);
                    minMax[1] = Math.max(minMax[1], floatValue);
                }
            }
            lines.push(tarr);
        }
    }

    return {headers:headers, minMax:minMax, data:lines};
}

function getResolution(t0, t1) {
    var res;
    var deltat = t1 - t0;
    var ms_min = 1000*60;
    var ms_hour = 1000*60*60;
    var ms_day = 1000*60*60*24;

    if (deltat >= ms_day*2) {
        // greater than 48h
        res = "hour";
    } else if (deltat >= ms_hour*12 && deltat < ms_day*2) {
        // between 12 hours and 2 days
        res = "five_minutes";
    } else if (deltat >= ms_hour && deltat < ms_hour*12){
        // between one hour and 12 hours
        res = "minute";
    } else if (deltat < ms_hour){
        // less than one hour
        res = "full";
    }

    return res;
}

// merge the new (higher res) data into the original, between start and end dates, replacing overlapping data
function mergeData(orig, newSubset, t0, t1) {
    var oldData = orig.data;
    var oldHeaders = newSubset.headers;
    var newMinMax = [null, null];
    var newData = newSubset.data;
    var merged = [];

    var head = [];
    var middle = [];
    var tail = [];

    if (newData.length == 0) {
        return orig;
    }

    if (t0 >= t1) {
        console.log("startDate is later than or equal to endDate");
        return orig;
    }

    // construct a new array that combines all elements of the original with new data inserted between t0 and t1
    for (var x = 0; x < oldData.length; x++) {
        if (oldData[x][0] < t0 ) {
            var conv = oldData[x];
            conv[0] = new Date(conv[0]);
            head.push(conv);
        }

        if (oldData[x][0] > t1 ) {
            var conv = oldData[x];
            conv[0] = new Date(conv[0]);
            tail.push(conv);
        }
    }

    // update min/max
    for (x = 0; x < newData.length; x++) {
        if (newData[x][0] >= t0 && newData[x][0] <= t1) {
            middle.push(newData[x]);

            for (var i=1; i < newData[x].length; i++) {
                var value = newData[x][i];
                if (newMinMax[0] == null) newMinMax[0] = value;
                if (newMinMax[1] == null) newMinMax[1] = value;

                newMinMax[0] = Math.min(newMinMax[0], value);
                newMinMax[1] = Math.max(newMinMax[1], value);
            }
        }
    }

    if (middle.length == 0) {
        return orig;
    }

    // Concat all valid arrays
    var merged = [];
    if (head.length > 0) {
        merged = merged.concat(head);
    }
    if (middle.length > 0) {
        merged = merged.concat(middle);
    }
    if (tail.length > 0) {
        merged = merged.concat(tail);
    }

    return {headers:oldHeaders, minMax:newMinMax, data:merged};

}

// using a very simple cache.  Avoids unnecessary downloading, especially useful on mobile.
function setCache(cache, res, data) {
    if (data) {
        if (cache[res]) {
            // sorting to a single merged array is expensive so keep an array of sorted arrays
            cache[res] = cache[res].concat(data);
        } else {
            cache[res] = [data];
        }
    }
}


// get an array of the proper resolution that contains the data between t0 and t1 otherwise return null.  Could use OOP here.
function getCache(cache, res, t0, t1) {
    if (!cache) {
        return null;
    }

    var cachedArrays = cache[res];
    if (cachedArrays) {
        for (var i=0; i<cachedArrays.length; i++) {
            var cachedData = cachedArrays[i].data;
            if (t0 >= cachedData[0][0] && t1 <= cachedData[cachedData.length-1][0]) {
                return cachedArrays[i];
            }
        }
    }

    return null;
}

// set the valueRange parameter in the input 'object' newOptions.  Uses the min and max values
// supplied, or the yRanges of the selected zoom if it's within the bounds of the data.
function updateGraph(graph, merged, yRanges) {
    var newOptions = {'file': merged.data, 'valueRange': merged.minMax};

    if (graph.isZoomed('y')) {
        // if the y zoom is within the min/max data it's likely a user supplied y-zoom.
        if (yRanges[0][0] >= merged.minMax[0] && yRanges[0][1] <= merged.minMax[1]) {
            newOptions['valueRange'] = yRanges[0];
        }
    }

    graph.updateOptions(newOptions);
}

// Callback used to download, cache, and display higher resolution data than default
function progressiveZoom(graph, minDate, maxDate, yRanges, csvUrl, data, cache) {
    var res = getResolution(minDate, maxDate);

    var cached = getCache(cache, res, minDate, maxDate);
    if (cached) {
        var merged = mergeData(data, cached, minDate, maxDate);
        updateGraph(graph, merged, yRanges);
        return;
    }

    // JS dates are in local timezone so convert to UTC
    var startDate = new Date(minDate - new Date().getTimezoneOffset()*60*1000).toISOString();
    var endDate = new Date(maxDate - new Date().getTimezoneOffset()*60*1000).toISOString();

    var request = new XMLHttpRequest();
    request.open('GET', csvUrl+"&resolution="+res+"&startDate="+startDate+"&endDate="+endDate, true);
    request.setRequestHeader ("Accept", "text/csv");

    request.onload = function() {
        if (request.status == 200) {
            var newData;
            // Success but check for null data.  If error we keep original data
            if (request.response) {
                newData = parseCsv(request.response);
                setCache(cache, res, newData);
                var merged = mergeData(data, newData, minDate, maxDate);
                updateGraph(graph, merged, yRanges);
            }
        }
    };

    request.send();
}

function downloadCsv(csvUrl, res, div, graphOptions, thresholds) {
    var request = new XMLHttpRequest();
    request.open('GET', csvUrl+"&resolution="+res, true);
    request.setRequestHeader ("Accept", "text/csv");

    request.onload = function() {
        if (request.status == 200) {
            var data;
            var cache = {};
            // Success but check for null data
            if (!request.response) {
                data = {headers: [null], data: [[null]]};
                graphOptions.title += " [Error: No Data Found]";
            } else {
                data = parseCsv(request.response);
                setCache(cache, res, data);
            }

            // success, plot the data
            plotData(div, csvUrl, data, graphOptions, thresholds, cache);
        } else {
            // We reached our target server, but it returned an error.  Plot a blank graph with the error message.
            graphOptions.title += " [Error fetching data: " + request.statusText + "]";
            plotData(div, csvUrl, {headers: [null], data: [[null]]}, graphOptions, thresholds, cache);
        }
    };

    request.onerror = function() {
        // There was a connection error of some sort
        graphOptions.title += " [Error fetching data: " + request.statusText + "]";
        plotData(div, csvUrl, {headers: [null], data: [[null]]}, graphOptions, thresholds, cache);
    };

    request.send();
}

function showGraph(csvUrl, res, graphOptions, thresholds) {
    var graphElement = document.getElementById('graphdiv');
    var div = document.createElement('div');
    div.style.width = '92vw'; // use X% of the available width (scales with changing width)
    div.style.marginLeft = '3vw';
    div.style.height = '400px';
    div.style.display = 'inline-block';
    // appending to parent div lets us plots as many graphs as we like
    graphElement.appendChild(div);

    if (!res) {
        res = "hour";
    }

    downloadCsv(csvUrl, res, div, graphOptions, thresholds);
}
